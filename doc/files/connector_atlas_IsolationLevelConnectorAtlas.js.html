<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>connector/atlas/IsolationLevelConnectorAtlas.js - DNSMON</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="../assets/favicon.png">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="../assets/css/logo.png" title="DNSMON"></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 14.4.25.2</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="../classes/AggregationLevelConnector.html">AggregationLevelConnector</a></li>
            
                <li><a href="../classes/AntiFloodConnector.html">AntiFloodConnector</a></li>
            
                <li><a href="../classes/BreadcrumbsView.html">BreadcrumbsView</a></li>
            
                <li><a href="../classes/CacheConnectorAtlas.html">CacheConnectorAtlas</a></li>
            
                <li><a href="../classes/Cell.html">Cell</a></li>
            
                <li><a href="../classes/Connector.html">Connector</a></li>
            
                <li><a href="../classes/ConnectorFacade.html">ConnectorFacade</a></li>
            
                <li><a href="../classes/ControlPanelView.html">ControlPanelView</a></li>
            
                <li><a href="../classes/ErrorsHandlerConnectorAtlas.html">ErrorsHandlerConnectorAtlas</a></li>
            
                <li><a href="../classes/FullScreenView.html">FullScreenView</a></li>
            
                <li><a href="../classes/GesturesManager.html">GesturesManager</a></li>
            
                <li><a href="../classes/HistoryManager.html">HistoryManager</a></li>
            
                <li><a href="../classes/IsolationLevelConnectorAtlas.html">IsolationLevelConnectorAtlas</a></li>
            
                <li><a href="../classes/MainView.html">MainView</a></li>
            
                <li><a href="../classes/ParamsManager.html">ParamsManager</a></li>
            
                <li><a href="../classes/PopUpView.html">PopUpView</a></li>
            
                <li><a href="../classes/Row.html">Row</a></li>
            
                <li><a href="../classes/SessionManager.html">SessionManager</a></li>
            
                <li><a href="../classes/SvgChartView.html">SvgChartView</a></li>
            
                <li><a href="../classes/SvgContainerView.html">SvgContainerView</a></li>
            
                <li><a href="../classes/SvgOrdinalAxisView.html">SvgOrdinalAxisView</a></li>
            
                <li><a href="../classes/SvgTimeAxisView.html">SvgTimeAxisView</a></li>
            
                <li><a href="../classes/TemplateManagerView.html">TemplateManagerView</a></li>
            
                <li><a href="../classes/TimeController.html">TimeController</a></li>
            
                <li><a href="../classes/TimeOverviewView.html">TimeOverviewView</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
                <li><a href="../modules/connector.html">connector</a></li>
            
                <li><a href="../modules/connector.Atlas.html">connector.Atlas</a></li>
            
                <li><a href="../modules/controller.html">controller</a></li>
            
                <li><a href="../modules/environment.html">environment</a></li>
            
                <li><a href="../modules/model.html">model</a></li>
            
                <li><a href="../modules/session.html">session</a></li>
            
                <li><a href="../modules/view.html">view</a></li>
            
                <li><a href="../modules/view.svg.html">view.svg</a></li>
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: connector/atlas/IsolationLevelConnectorAtlas.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
/**
 * Created with JetBrains WebStorm.
 * User: mcandela
 * Date: 10/17/13
 * Time: 11:35 AM
 * To change this template use File | Settings | File Templates.
 */



// Coupled with the model layer

define(
    [
        &quot;env.utils&quot;,
        &quot;env.params-manager&quot;,
        &quot;model.cell&quot;,
        &quot;model.row&quot;,
        &quot;connector.atlas.cache&quot;,
        &quot;lib.atlas-traceroute-printer&quot;
    ],
    function(utils, paramsManager, Cell, Row, Connector){

        /**
         * IsolationLevelConnectorAtlas has a fundamental role providing isolation between the internal input format
         * and the external input format. It allows to block the propagation of changes affecting the JSON format
         * provided by the data-api. In addition it is a transposition level between a format convenient for the
         * data-api (e.g. light data data format) and a format convenient for the tool (e.g. less computation format).
         *
         * @class IsolationLevelConnectorAtlas
         * @constructor
         * @module connector.Atlas
         */

        var IsolationLevelConnectorAtlas = function(env){

            var connector, dataNomenclatureMapping, maxUsedDate, minUsedDate, crowdestRow, envelop, config, originalTime;

            connector = new Connector(env);
            config = env.config;

            dataNomenclatureMapping = {
                startTimestamp: &quot;start_time&quot;,
                endTimestamp: &quot;end_time&quot;,
                aggregationLevel: &quot;aggregation&quot;,
                probesList: &quot;probes&quot;,
                serversList: &quot;servers&quot;,
                isOngoing: &quot;active&quot;,

                aggregationLevels: &quot;aggregation_levels&quot;,
                measurementStartTime: &quot;earliest_available&quot;,
                measurementEndTime: &quot;latest_available&quot;,
                aggregationLabel: &quot;aggregation_label&quot;,
                nativeAvailable: &quot;native_available&quot;,

                singleZone: &quot;group&quot;,
                singleServer: &quot;server&quot;,

                zone: {
                    id: &quot;id&quot;,
                    label: &quot;label&quot;,
                    description: &quot;description&quot;,
                    isOngoing: &quot;active&quot;
                },

                server: {
                    id: &quot;id&quot;,
                    hostname: &quot;hostname&quot;,
                    resultsList: &quot;results&quot;,
                    ipVersion: &quot;ip_version&quot;,
                    ipAddress: &quot;ip_address&quot;,
                    label: &quot;label&quot;,
                    description: &quot;description&quot;,
                    urlsMap: &quot;atlas_measurements&quot;
                },

                urlItem: {
                    typeId: &quot;type&quot;,
                    label: &quot;type_label&quot;,
                    overviewUrl: &quot;overview_url&quot;,
                    dataUrl: &quot;result_url&quot;,
                    measurementId: &quot;msm_id&quot;,
                    currentDatasource: &quot;data_source&quot;,
                    samplingFrequency: &quot;interval&quot;
                },

                probe: {
                    id: &quot;id&quot;,
                    country: &quot;country&quot;,
                    label: &quot;label&quot;,
                    description: &quot;description&quot;,
                    hostname: &quot;hostname&quot;,
                    resultsList: &quot;results&quot;
                },

                result: {
                    respondingTime: &quot;rtt50&quot;,
                    packetSent: &quot;queries&quot;,
                    packetReceived: &quot;replies&quot;,
                    time: &quot;time&quot;,
                    endTime: &quot;end_time&quot;,
                    errors: &quot;errors&quot;
                },

                managedRcodes: [&quot;ServFail&quot;, &quot;NXDomain&quot;, &quot;Refused&quot;]
            };


            /**
             * It is strongly related to a particular JSON format.
             * From top to bottom: uses paramsManager to translate the internal format of the parameters in the format valid outside.
             * From bottom to top: translates the external input data in the internal format.
             *
             * @method retrieveData
             * @param {Object} params A params vector
             * @param {Function} callback A function taking the retrieved data as input when it is ready
             * @param {Object} context The context of the callback
             */

            this.retrieveData = function(params, callback, context){

                params = this._parseParams(params); //Translates the internal format of the parameters in the format valid outside

                //Just an indirection for now
                connector.retrieveData(params, function(data){
                    var wrappedData = this._parseData(data);

                    callback.call(context, wrappedData); // Back to the normal data flow

                }, this); // Data callback context
            };


            /**
             * This method translates parameters from the internal to the external format
             *
             * @method _parseParams
             * @param {Object} params A params vector
             * @return {Object} A params vector in the internal format
             */
            this._parseParams = function(params){
                return paramsManager.fromInternalToExternal(params);
            };


            /**
             * This method translates a server from the external to the internal format
             *
             * @method _parseSingleServer
             * @param {Object} server A server described in the external format
             * @return {Object} A server described in the internal format
             */

            this._parseSingleServer = function(server){
                var serverNomenclature, serverObj;

                serverNomenclature = dataNomenclatureMapping.server;
                serverObj = {
                    id: paramsManager.convertRemoteToLocalId(server[serverNomenclature.id]),
                    label: server[serverNomenclature.label] || server[serverNomenclature.hostname] + &#x27; &#x27; + ((server[serverNomenclature.ipVersion] == 4) ? &#x27;IPv4&#x27;: &#x27;IPv6&#x27;),
                    description: server[serverNomenclature.description],
                    urlsMap: this._generateJsonUrls(server[serverNomenclature.urlsMap])
                };

                return serverObj;
            };


            /**
             * This method translates a zone from the external to the internal format
             *
             * @method _parseSingleServer
             * @param {Object} zone A zone described in the external format
             * @return {Object} A zone described in the internal format
             */

            this._parseZone = function(zone){
                var zoneNomenclature, zoneObj;

                zoneNomenclature = dataNomenclatureMapping.zone;
                zoneObj = {
                    id: paramsManager.convertRemoteToLocalId(zone[zoneNomenclature.id]),
                    label: zone[zoneNomenclature.label]
                };

                env.isOngoing = zone[zoneNomenclature.isOngoing];

                return zoneObj;
            };


            /**
             * This method initialises the parsing of the input JSON
             *
             * @method _parseData
             * @private
             * @param {Object} data The external data structure
             * @return {Object} The internal data structure
             */

            this._parseData = function(data){
                maxUsedDate = null;
                minUsedDate = null;

                crowdestRow = {cells: []};

                originalTime = {
                    start: data[dataNomenclatureMapping.startTimestamp],
                    end: data[dataNomenclatureMapping.endTimestamp]
                };

                envelop = { // Creates the internal data structure
                    startDate: paramsManager.convertRemoteToLocalDate(originalTime.start),
                    endDate: paramsManager.convertRemoteToLocalDate(originalTime.end),
                    rows: [],
                    cells: [],
                    group: null
                };

                // Synchronizes the internal parameters with those returned
                env.params.startDate = envelop.startDate;
                env.params.endDate = envelop.endDate;

                env.retrievedAggregationLevel = data[dataNomenclatureMapping.aggregationLevel];

                if (data.type == &quot;server-probes&quot;){ // Different parser based on data.type

                    envelop.group = this._parseSingleServer(data[dataNomenclatureMapping.singleServer]);
                    envelop.root = this._parseZone(data[dataNomenclatureMapping.singleZone]);
                    this._parseProbes(data[dataNomenclatureMapping.probesList]);

                }else if (data.type == &quot;zone-servers&quot;){

                    envelop.group = this._parseZone(data[dataNomenclatureMapping.singleZone]);
                    this._parseServers(data[dataNomenclatureMapping.serversList]);

                }else{
                    console.log(&quot;Malformed json!&quot;);
                }

                envelop.maxUsedDate = maxUsedDate;
                envelop.minUsedDate = minUsedDate;


                // Computes some internal parameters
                env.aggregationLevels = data[dataNomenclatureMapping.aggregationLevels];
                env.minAggregation = env.aggregationLevels[0];
                env.maxAggregation = env.aggregationLevels[env.aggregationLevels.length - 1];
                env.measurementStartTime = paramsManager.convertRemoteToLocalDate(data[dataNomenclatureMapping.measurementStartTime]);
                env.measurementEndTime = paramsManager.convertRemoteToLocalDate(data[dataNomenclatureMapping.measurementEndTime]);

                env.aggregationLabel = data[dataNomenclatureMapping.aggregationLabel];
                env.isNativeAvailable = data[dataNomenclatureMapping.nativeAvailable];

                envelop.usedTimeWindowSeconds = Math.ceil((maxUsedDate - minUsedDate)/1000);
                env.timeWindowSeconds = Math.ceil((env.params.endDate - env.params.startDate)/1000);
                envelop.crowdestRow = crowdestRow;

                if (minUsedDate &lt; env.params.startDate){
                    utils.log(&#x27;Warning: an element retrieved is before the start date&#x27;, env.debugMode);
                }

                return envelop;
            };


            /**
             * Parses all the servers available in the JSON in order to create an internal compatible version of them
             *
             * @method _parseServers
             * @private
             * @param {Object} servers A list of server
             */

            this._parseServers = function(servers){
                var row, rowId, rowLabel, objRow, serverNomenclature, rowResults, resultsObjList, rowGroup, rowIpVersion,
                    rowDescription, externalId, rowHostname, rowIp, multipleLabels;

                serverNomenclature = dataNomenclatureMapping.server;
                multipleLabels = {};

                for (var n=0,length=servers.length; n&lt;length; n++){ // For all the servers
                    row = servers[n];

                    externalId = row[serverNomenclature.id];
                    rowId = paramsManager.convertRemoteToLocalId(externalId);
                    rowResults = row[serverNomenclature.resultsList];

                    rowHostname = row[serverNomenclature.hostname];
                    rowGroup = rowHostname; // Grouped by host name

                    rowIpVersion = row[serverNomenclature.ipVersion];
                    rowIp = row[serverNomenclature.ipAddress];

                    rowDescription = row[serverNomenclature.description] || rowIp + &#x27; (&#x27; + rowHostname + &#x27;)&#x27;;

                    rowLabel = row[serverNomenclature.label] || this._abbreviateLabel(rowHostname) + &#x27; &#x27; + ((rowIpVersion == 4) ? &#x27;IPv4&#x27;: &#x27;IPv6&#x27;);

                    if (multipleLabels[rowLabel]){
                        multipleLabels[rowLabel]++;
                        rowLabel += &#x27;(&#x27; + multipleLabels[rowLabel] + &#x27;)&#x27;;
                    }else{
                        multipleLabels[rowLabel] = 1;
                    }

                    objRow  = new Row(rowId, rowLabel); // Create a row object of the model layer
                    objRow.group = rowGroup;
                    objRow.internalOrder = rowIpVersion;
                    objRow.description = rowDescription;
                    objRow.minimumResponseTime = null;
                    objRow.___externalId___ = externalId;
                    objRow.___type___ = &quot;server&quot;;

                    objRow.urlsMap = this._generateJsonUrls(row[serverNomenclature.urlsMap]); // Get additional data-api URLs

                    resultsObjList = this._parseResults(rowResults, objRow); // Parse all the results for this row

                    envelop.rows.push(objRow);
                }

            };


            /**
             * This method translates the URLs of additional data-api reported in the JSON in the internal format
             *
             * @method _generateJsonUrls
             * @private
             * @param {Object} urlsMap A map of URLs
             * @return {Object} A map of URLs translated in the internal format
             */

            this._generateJsonUrls = function(urlsMap){
                var jsonOverviewUrls, jsonSampleUrls, dataUrl, overviewUrl, label, nomenclatureUrlMap, mapUrlItem,
                    current, measurementId, typeId, samplingFrequency;

                jsonOverviewUrls = [];
                jsonSampleUrls = [];
                nomenclatureUrlMap = dataNomenclatureMapping.urlItem;

                for (var n=0,length=urlsMap.length; n&lt;length; n++){

                    mapUrlItem = urlsMap[n];
                    label = mapUrlItem[nomenclatureUrlMap.label];
                    overviewUrl = mapUrlItem[nomenclatureUrlMap.overviewUrl];
                    dataUrl = mapUrlItem[nomenclatureUrlMap.dataUrl];
                    measurementId = mapUrlItem[nomenclatureUrlMap.measurementId];
                    typeId = mapUrlItem[nomenclatureUrlMap.typeId];
                    current = (mapUrlItem[nomenclatureUrlMap.currentDatasource] == true);

                    samplingFrequency = mapUrlItem[nomenclatureUrlMap.samplingFrequency];

                    if (current){
                        env.samplingFrequency = samplingFrequency;
                    }

                    if (typeId != 3){
                        jsonOverviewUrls.push({type: typeId, label: label, url: overviewUrl, current: current, measurementId: measurementId, samplingFrequency: samplingFrequency});
                        jsonSampleUrls.push({type: typeId, label: label, url: dataUrl, current: current, measurementId: measurementId, samplingFrequency: samplingFrequency});
                    }
                }

                return {sample: jsonSampleUrls, overview: jsonOverviewUrls};
            };


            /**
             * This method abbreviates the labels for IPv6 addresses
             *
             * @method _abbreviateIPv6Label
             * @private
             * @param {String} label An IP address
             */

            this._abbreviateIPv6Label = function(label){
                var blocks, fullBlocks, blockTmp, resultBlocksHead, resultBlocksTail, labelOut;

                fullBlocks = [];
                resultBlocksHead = [];
                resultBlocksTail = [];
                blocks = label.split(&quot;:&quot;);

                for (var n=0,length=blocks.length; n&lt;length; n++){
                    blockTmp = blocks[n];
                    if (blockTmp != &quot;&quot;) {
                        fullBlocks.push(blockTmp);
                    }
                }

                if (fullBlocks.length &gt; 4){
                    resultBlocksHead.push(fullBlocks[0]);
                    resultBlocksHead.push(fullBlocks[1]);

                    resultBlocksTail.push(fullBlocks[fullBlocks.length - 2]);
                    resultBlocksTail.push(fullBlocks[fullBlocks.length - 1]);

                    labelOut = utils.join(resultBlocksHead, &quot;:&quot;) + &quot;:..:&quot; + utils.join(resultBlocksTail, &quot;:&quot;);
                }else{
                    labelOut = label;
                }

                return labelOut;

            };



            /**
             * This method abbreviates the labels
             *
             * @method _abbreviateLabel
             * @private
             * @param {String} label A label
             */

            this._abbreviateLabel = function(label){
                var stringOut, firstPart, secondPart, startSecondPart, length;

                length = label.length;
                if (length &gt;= config.maxYLabelLength){
                    startSecondPart = length - 4;

                    firstPart = (label.charAt(7) != &#x27;.&#x27;) ? label.substring(0, 8) : label.substring(0, 7);
                    secondPart = (label.charAt(startSecondPart) != &#x27;.&#x27;) ? label.substring(startSecondPart, length) : label.substring(startSecondPart + 1, length);

                    stringOut = firstPart + &#x27;...&#x27; + secondPart;
                }else{
                    stringOut = label;
                }

                return stringOut;
            };


            /**
             * Parses all the probes available in the JSON in order to create an internal compatible version of them
             *
             * @method _parseProbes
             * @private
             * @param {Object} probes A list of probes
             */

            this._parseProbes = function(probes){
                var row, rowId, rowLabel, objRow, probeNomenclature, rowResults, resultsObjList, rowGroup,
                    rowDescription, externalId, rowCountry, rowHostname;

                probeNomenclature = dataNomenclatureMapping.probe;

                for (var n=0,length=probes.length; n&lt;length; n++){
                    row = probes[n];

                    externalId = row[probeNomenclature.id];

                    rowId = paramsManager.convertRemoteToLocalId(externalId);
                    rowResults = row[probeNomenclature.resultsList];
                    rowCountry = row[probeNomenclature.country];
                    rowHostname = row[probeNomenclature.hostname];
                    rowGroup = rowCountry;
                    rowLabel = row[probeNomenclature.label] || rowHostname + &#x27; (&#x27; + rowCountry + &#x27;)&#x27;;
                    rowDescription = row[probeNomenclature.description] || rowHostname;

                    objRow  = new Row(rowId, rowLabel); //Label modified for now
                    objRow.group = rowGroup;
                    objRow.internalOrder = rowId;
                    objRow.description = rowDescription;
                    objRow.minimumResponseTime = null;
                    objRow.___externalId___ = externalId;
                    objRow.___type___ = &quot;probe&quot;;

                    objRow.urlsMap = envelop.group.urlsMap;

                    resultsObjList = this._parseResults(rowResults, objRow);
                    envelop.rows.push(objRow);
                }

            };


            /**
             * Parses all results retrieved in the JSON for the current row
             *
             * @method _parseResults
             * @private
             * @param {Object} results A list of results
             * @param {Object} row An object of the model layer representing the row
             */

            this._parseResults = function(results, row){
                var cell, objCell, cellResponseTime, cellTime, resultNomenclature, cellLoss, cellTimeEnd,
                    lastSampleDate, startTimestamp, endTimestamp;

                resultNomenclature = dataNomenclatureMapping.result; // Get the nomenclature for a result item

                for (var n=0,length=results.length; n&lt;length; n++){ // Iterate an all the results
                    cell = results[n];

                    startTimestamp = cell[resultNomenclature.time];
                    endTimestamp = cell[resultNomenclature.endTime];

                    cellTime = paramsManager.convertRemoteToLocalDate(startTimestamp); // The start time MUST be every time specified by the server

                    if (endTimestamp){ // The end time is specified by the server

                        cellTimeEnd = paramsManager.convertRemoteToLocalDate(endTimestamp);

                    }else{

                        if (env.retrievedAggregationLevel != 0){ // It is an aggregation, so every single cell is representing a period with start and end time

                            cellTimeEnd = paramsManager.convertRemoteToLocalDate(startTimestamp + env.retrievedAggregationLevel); // Computes the end time

                        }else{ // It is a sample with just startTime

                            cellTimeEnd = null;

                        }
                    }

                    cellResponseTime = this._computeRespondingTime(cell);
                    cellLoss = this._computePacketLoss(cell);

                    if (maxUsedDate == null){
                        maxUsedDate = cellTime;
                        minUsedDate = cellTime;
                    }else{
                        maxUsedDate = (maxUsedDate &gt; cellTime) ? maxUsedDate : cellTime;
                        minUsedDate = (minUsedDate &lt; cellTime) ? minUsedDate : cellTime;
                    }

                    objCell = new Cell(row, cellTime); // Create a new object of the model layer

                    this._parseRcodes(objCell, cell);

                    objCell.endTime = cellTimeEnd;
                    objCell.respondingTime = cellResponseTime;
                    objCell.loss = cellLoss;
                    objCell.sent = cell[dataNomenclatureMapping.result.packetSent];

                    envelop.cells.push(objCell);

                    row.cells.push(objCell); // Set the current cell to the current row

                    if (cellResponseTime != null){
                        row.minimumResponseTime = (row.minimumResponseTime == null || row.minimumResponseTime &gt; cellResponseTime) ? cellResponseTime : row.minimumResponseTime;
                    }

                    crowdestRow = (row.cells.length &gt; crowdestRow.cells.length) ? row : crowdestRow;

                    lastSampleDate = cellTime;
                }
            };

            /**
             * Enriches the cell object of the model layer with the rcodes error retrieved in the JSON for the conresponding result
             *
             * @method _parseRcodes
             * @private
             * @param {Object} cell An object of the model layer
             * @param {Object} cellData A result/cell of the JSON input
             */

            this._parseRcodes = function(cell, cellData){
                var errorsData, importantErrors, others, totalNumber, cellError, numberOfErrorsOfThisType;

                others = 0;
                totalNumber = 0;
                importantErrors = dataNomenclatureMapping.managedRcodes;
                errorsData = cellData[dataNomenclatureMapping.result.errors];
                cellError = {};

                for (var errorName in errorsData){

                    if (utils.indexOf(errorName, importantErrors)){
                        numberOfErrorsOfThisType = errorsData[errorName];
                        totalNumber += numberOfErrorsOfThisType;
                        cellError[errorName] = numberOfErrorsOfThisType;
                    }else{
                        totalNumber++;
                        others++;
                    }
                    cellError[&quot;others&quot;] = others;
                }

                cell.errors = cellError;
                cell.numberCorrectResponses = this._computeNumberCorrectResponses(cellData, totalNumber);
            };


            /**
             * Computes the percentage of correct responses
             *
             * @method _computeNumberCorrectResponses
             * @private
             * @param {Object} cellData A result/cell of the JSON input
             * @return {Number} Returns a percentage
             */

            this._computeNumberCorrectResponses = function(cellData, numberOfErrors){
                var packetLoss;

                packetLoss = cellData[dataNomenclatureMapping.result.packetSent] - (cellData[dataNomenclatureMapping.result.packetReceived] - numberOfErrors);
                packetLoss = (100 / cellData[dataNomenclatureMapping.result.packetSent]) * packetLoss;
                return packetLoss.toFixed(2);
            };

            /**
             * Computes the unanswered queries of a cell/result
             *
             * @method _computePacketLoss
             * @private
             * @param {Object} cellData A result/cell of the JSON input
             * @return {float} Returns a percentage
             */

            this._computePacketLoss = function(cellData){
                var packetLoss;
                packetLoss = cellData[dataNomenclatureMapping.result.packetSent] - cellData[dataNomenclatureMapping.result.packetReceived];

                packetLoss = (100 / cellData[dataNomenclatureMapping.result.packetSent]) * packetLoss;
                return packetLoss.toFixed(2);
            };


            /**
             * Computes the RTT of a cell/result
             *
             * @method _computeRespondingTime
             * @private
             * @param {Object} cellData A result/cell of the JSON input
             * @return {Number} Returns a RTT value
             */
            this._computeRespondingTime = function(cellData){
                var rtt, resultNomenclature;

                resultNomenclature = dataNomenclatureMapping.result;
                rtt = cellData[resultNomenclature.respondingTime];

                return rtt;
            };


            /**
             * Get the DNS response data and translates it in an internal stable format
             *
             * @method getNativeDnsResult
             * @param {Number} msmId The id of the measurement
             * @param {Number} prbId The id of the probe
             * @param {Number} timestamp A UNIX timestamp
             * @param {Function} callback A function taking the retrieved data as input when it is ready
             * @param {Object} context The context of the callback
             */

            this.getNativeDnsResult = function(msmId, prbId, timestamp, callback, context){
                var nomenclatureDnsResponse;

                nomenclatureDnsResponse = {
                    probeId: &quot;prb_id&quot;,
                    responseTime: &quot;rt&quot;,
                    nsId: &quot;nsid&quot;,
                    date: &quot;timestamp&quot;,
                    response: &quot;answer&quot;,
                    error: &quot;error&quot;
                };

                connector.getNativeDnsResult(msmId, prbId, timestamp, function(data){
                    var internalResponse, newData, dataItem;

                    newData = [];

                    for (var n= 0,length=data.length; n&lt;length; n++){
                        dataItem = data[n];

                        internalResponse = { // Translate to internal object
                            probeId: dataItem[nomenclatureDnsResponse.probeId],
                            responseTime: dataItem[nomenclatureDnsResponse.responseTime] || &quot;NA&quot;,
                            date: paramsManager.convertRemoteToLocalDate(dataItem[nomenclatureDnsResponse.date]),
                            nsId: dataItem[nomenclatureDnsResponse.nsId],
                            response: dataItem[nomenclatureDnsResponse.response],
                            error: dataItem[nomenclatureDnsResponse.error]
                        };

                        newData.push(internalResponse);
                    }

                    callback.call(context, newData);
                }, this);
            };


            /**
             * Get the closest traceroutes data and translates it in an internal stable format
             *
             * @method getClosestTraceroutes
             * @param {Number} msmId The id of the measurement
             * @param {Number} prbId The id of the probe
             * @param {Number} timestamp A UNIX timestamp
             * @param {Function} callback A function taking the retrieved data as input when it is ready
             * @param {Object} context The context of the callback
             */

            this.getClosestTraceroutes = function(msmId, prbId, timestamp, callback, context){
                var nomenclatureDnsResponse, tracerouteAtlas;

//                nomenclatureDnsResponse = {
//                    probeId: &quot;prb_id&quot;,
//                    date: &quot;timestamp&quot;,
//                    response: &quot;result&quot;
//                };

                connector.getClosestTraceroutes(msmId, prbId, timestamp, function(data){
                    var closestTraceroutes, newData, dataItem;

                    newData = [];

//                    for (var n= 0,length=data.length; n&lt;length; n++){
//                        dataItem = data[n];+
//
//                        closestTraceroutes = { // Translate to internal object
//                            probeId: dataItem[nomenclatureDnsResponse.probeId],
//                            date: paramsManager.convertRemoteToLocalDate(dataItem[nomenclatureDnsResponse.date]),
//                            response: dataItem[nomenclatureDnsResponse.response]
//                        };
//
//                        newData.push(closestTraceroutes);
//                    }


                    for (var n=0,length=data.length; n&lt;length; n++){
                        tracerouteAtlas = new AtlasTraceroute(data[n]);
                        tracerouteAtlas.renderTimestring = function(timestamp){
                            return &#x27;&gt;&gt;&gt; &#x27; + utils.dateToString(utils.timestampToLocalDate(timestamp));
                        };

                        newData.push(tracerouteAtlas.render());
                    }

                    callback.call(context, newData);
                }, this);
            };

        };


        return IsolationLevelConnectorAtlas;
    });

    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
