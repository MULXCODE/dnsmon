<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>controller/GesturesManager.js - DNSMON</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="../assets/favicon.png">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="../assets/css/logo.png" title="DNSMON"></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 14.4.15.2</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="../classes/AggregationLevelConnector.html">AggregationLevelConnector</a></li>
            
                <li><a href="../classes/AntiFloodConnector.html">AntiFloodConnector</a></li>
            
                <li><a href="../classes/BreadcrumbsView.html">BreadcrumbsView</a></li>
            
                <li><a href="../classes/CacheConnectorAtlas.html">CacheConnectorAtlas</a></li>
            
                <li><a href="../classes/Cell.html">Cell</a></li>
            
                <li><a href="../classes/Connector.html">Connector</a></li>
            
                <li><a href="../classes/ConnectorFacade.html">ConnectorFacade</a></li>
            
                <li><a href="../classes/ControlPanelView.html">ControlPanelView</a></li>
            
                <li><a href="../classes/ErrorsHandlerConnectorAtlas.html">ErrorsHandlerConnectorAtlas</a></li>
            
                <li><a href="../classes/FullScreenView.html">FullScreenView</a></li>
            
                <li><a href="../classes/GesturesManager.html">GesturesManager</a></li>
            
                <li><a href="../classes/HistoryManager.html">HistoryManager</a></li>
            
                <li><a href="../classes/IsolationLevelConnectorAtlas.html">IsolationLevelConnectorAtlas</a></li>
            
                <li><a href="../classes/MainView.html">MainView</a></li>
            
                <li><a href="../classes/ParamsManager.html">ParamsManager</a></li>
            
                <li><a href="../classes/PopUpView.html">PopUpView</a></li>
            
                <li><a href="../classes/Row.html">Row</a></li>
            
                <li><a href="../classes/SessionManager.html">SessionManager</a></li>
            
                <li><a href="../classes/SvgChartView.html">SvgChartView</a></li>
            
                <li><a href="../classes/SvgContainerView.html">SvgContainerView</a></li>
            
                <li><a href="../classes/SvgOrdinalAxisView.html">SvgOrdinalAxisView</a></li>
            
                <li><a href="../classes/SvgTimeAxisView.html">SvgTimeAxisView</a></li>
            
                <li><a href="../classes/TemplateManagerView.html">TemplateManagerView</a></li>
            
                <li><a href="../classes/TimeController.html">TimeController</a></li>
            
                <li><a href="../classes/TimeOverviewView.html">TimeOverviewView</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
                <li><a href="../modules/connector.html">connector</a></li>
            
                <li><a href="../modules/connector.Atlas.html">connector.Atlas</a></li>
            
                <li><a href="../modules/controller.html">controller</a></li>
            
                <li><a href="../modules/environment.html">environment</a></li>
            
                <li><a href="../modules/model.html">model</a></li>
            
                <li><a href="../modules/session.html">session</a></li>
            
                <li><a href="../modules/view.html">view</a></li>
            
                <li><a href="../modules/view.svg.html">view.svg</a></li>
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: controller/GesturesManager.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
/**
 * Created with JetBrains WebStorm.
 * User: mcandela
 * Date: 9/20/13
 * Time: 10:59 AM
 * To change this template use File | Settings | File Templates.
 */

define([
    &quot;env.utils&quot;,
    &quot;lib.d3&quot;
], function(utils, d3){

    /**
     * GesturesManager provides all the features handling user gestures/interactions.
     *
     * @class GesturesManager
     * @constructor
     * @module controller
     */

    var GesturesManager =  function(env){
        var $this, config, mouseWheelSensibility, eventsAttachedOn;

        $this = this;
        config = env.config;
        mouseWheelSensibility = config.mouseWheelSensibility;

        this.alreadyInit = false;
        this.eventsList = {};
        this.eventsList.scrollDown = [];
        this.eventsList.scrollUp = [];
        this.eventsList.scrollLeft = [];
        this.eventsList.scrollRight = [];

        env.timeEventsActive = true;


        /**
         * Attach a callback to a gesture
         *
         * @method on
         * @param {String} evt An event id
         * @param {Function} callback A callback
         * @param {Object} context The context of the callback
         */

        this.on = function(evt, func, context){

            if (!this.alreadyInit) {
                this._init();
                this.alreadyInit = true;
            }

            this.eventsList[evt].push({
                bindedFunction: func,
                context: context
            });

        };


        /**
         * Initialise all the events related to the mouse wheel
         *
         * @method _initMouseWheel
         * @private
         */

        this._initMouseWheel = function(){
            env.container.chart.dom.$.on(&#x27;DOMMouseScroll mousewheel&#x27;, function (evt) {
                var list, element, newYDomain, wheelDelta, characherization;

                evt.preventDefault();

                if (mouseWheelSensibility != 0){
                    mouseWheelSensibility--;
                    return false;
                }else{
                    mouseWheelSensibility = config.mouseWheelSensibility;
                }

                list = [];

                if (env.timeEventsActive ==  true){

                    if (env.isUpdatedPeriodicallyActive){ // Disable the auto refresh function if active
                        env.mainView.controlPanel.keepUpdatedActive(false);
                    }

                    wheelDelta = evt.originalEvent.detail || -(evt.originalEvent.wheelDelta/120);

                    if (wheelDelta &lt; 0) { //alternative options for wheelData: wheelDeltaX &amp; wheelDeltaY

                        list = $this.eventsList.scrollDown;

                    }else{

                        if (config.allRowsZoomingOut &amp;&amp; $this.rowsSubSelection){ // It is possible to get all the rows before to zoom out, check config.allRowsZoomingOut

                            $this.rowsSubSelection = false;
                            env.timeEventsActive = false;
                            env.params.selectedRows = [];
                            characherization = env.mainView.rowsCharacterization(env.mainView.rows);
                            newYDomain = characherization.domain;
                            env.mainView.yAxis.setDomain(function(){return newYDomain;});
                            env.mainView.redraw();

                        }else{
                            list = $this.eventsList.scrollUp;
                        }

                    }

                    for (var n=0,length=list.length; n&lt;length; n++){
                        element = list[n];
                        element.bindedFunction.call(element.context, wheelDelta);
                    }

                }
                return false;
            });

            eventsAttachedOn.$.keydown(function(evt){
                var list, element, key;

                if (env.timeEventsActive ==  true){
                    key = (evt.which) ? evt.which : evt.keyCode;
                    switch(key){
                        case 37: //Left
                            list = $this.eventsList.scrollLeft;
                            break;

                        case 39: //Right
                            list = $this.eventsList.scrollRight;
                            break;
                    }

                    if (list){
                        evt.preventDefault();

                        for (var n=0,length=list.length; n&lt;length; n++){
                            element = list[n];
                            element.bindedFunction.call(element.context);
                        }
                    }
                }

            });

        };


        /**
         * Initialise all the events
         *
         * @method _init
         * @private
         */

        this._init = function(){
            eventsAttachedOn = env.document;
            env.timeEventsActive = true;
            this._initMouseWheel();
            this._initializeSelectionTool();
            this._initializeActiveLabels();
        };


        /**
         * Initialise labels on the y-axis
         *
         * @method _initializeActiveLabels
         * @private
         */

        this._initializeActiveLabels = function(){
            env.mainView.yAxis.onClick(function(evt){
                var selectedRow, queryType, triggerAction;

                triggerAction = false;
                queryType = env.params.type;
                selectedRow = $(this).attr(&quot;magnet&quot;);

                switch(queryType){

                    case &quot;probes&quot;:
                        window.open(env.connector.getProbesPageUrl(selectedRow, env.params), &quot;_blank&quot;);
                        break;

                    case &quot;servers&quot;:
                        env.params.type = &quot;probes&quot;;
                        env.params.root = env.params.group;
                        env.params.group = selectedRow;
                        env.params.selectedRows = [];
                        triggerAction = true;
                        break;
                }

                if (triggerAction == true){
                    env.mainView.breadcrumbs.addLevel($(this).text());
                    env.mainView.redraw();
                }
            });
        };


        /**
         * Initialise the selection tool
         *
         * @method _initializeSelectionTool
         * @private
         */

        this._initializeSelectionTool = function(){
            var svg, body, selectionRect, endCoords, trackerDomElement, container, params, chart, selectedCells,
                removeSelectionWithFeedback, coords, startCoords, currentElement, coordsMousemove, finalStartCoords,
                finalEndCoords, removeRect, startSelection, stopSelection,
                getNormalCellColor, getSelectedCellColor, updateSelectionTimes, selectedRectsBoundingBox,
                updateSelectionNormal, updateSelectionLowProfile, dragStarted, selectionTooltipStart, selectionTooltipStop;

            container = env.container;
            params = env.params;
            chart = container.chart;
            svg = chart.svg;
            body = d3.select(&quot;body&quot;);


            trackerDomElement = svg;

            selectedRectsBoundingBox = {min: {x: Infinity, y: Infinity}, max: {x: -1, y: -1}}; //Reset the selection boundaries

            trackerDomElement.style(&quot;cursor&quot;, config.style.selectionCursor);


            // This function removes the selection providing a feedback for the user
            removeSelectionWithFeedback = function(event){

                if (event.target.nodeName != &#x27;rect&#x27; &amp;&amp; event.target.nodeName != &#x27;svg&#x27;){

                    if (selectionRect){ //Remove the low profile selection rect
                        selectionRect
                            .transition()
                            .duration(config.selectionWithdrawalDuration)
                            .attr(&quot;width&quot;, &quot;0&quot;)
                            .attr(&quot;height&quot;, &quot;0&quot;)
                            .remove();
                    }

                    selectionTooltipStart.remove();
                    selectionTooltipStop.remove();

                    if(selectedCells &amp;&amp; env.lowProfile == false){ //Remove the selected rectangles
                        selectedCells
                            .transition()
                            .duration(config.selectionWithdrawalDuration)
                            .style(&quot;fill&quot;, getNormalCellColor);
                    }

                    currentElement = null;

                    env.timeEventsActive = true;

                    body.classed(&quot;stat-noselect&quot;, false); //Remove the non-selection from all the dom
                    eventsAttachedOn.$.off(&quot;mouseup.selection&quot;).off(&quot;keyup.selection&quot;); // Remove useless listeners
                    document.onselectstart = function(){return true;}; //Remove the cursor hack
                    trackerDomElement.on(&quot;mousemove&quot;, null);// .on(&quot;mouseup&quot;, null); //Remove the selection events
                }
            };


            // This function provides the selection feature in the low-profile mode
            updateSelectionLowProfile = function(){
                var chartHeight, chartWidth, x, y, width, height, tooltipsOffset, dates, startDateString, endDateString,
                    tooltipWidth;

                if (currentElement == null) return;

                coordsMousemove = d3.mouse(currentElement);

                chartHeight = chart.height();
                chartWidth = chart.width();

                tooltipsOffset = 3;

                // The following lines bound the selection inside the chart
                coordsMousemove[0] = (coordsMousemove[0] &gt; 0) ? coordsMousemove[0] : 1 ;
                coordsMousemove[0] = (coordsMousemove[0] &lt; chartWidth) ? coordsMousemove[0] : chartWidth ;

                coordsMousemove[1] = (coordsMousemove[1] &gt; 0) ? coordsMousemove[1] : 1 ;
                coordsMousemove[1] = (coordsMousemove[1] &lt; chartHeight) ? coordsMousemove[1] : chartHeight ;

                endCoords = {x: ((coordsMousemove[0] &gt; 0) ? coordsMousemove[0] : 1 ), y: coordsMousemove[1]};
                dragStarted = true;

                x = Math.min(startCoords.x, endCoords.x);
                y = Math.min(startCoords.y, endCoords.y);
                width = Math.abs(startCoords.x - endCoords.x);
                height = Math.abs(startCoords.y - endCoords.y);

                dates = $this._computeSubDomains(startCoords, endCoords);

                startDateString = utils.dateToString(dates[0][0]);
                endDateString = utils.dateToString(dates[0][1]);

                tooltipWidth = (startDateString.length * 8); // Where 8 is the base width of a char in the tooltip (don&#x27;t retrieve it for performance purposes)

                selectionTooltipStart
                    .css({
                        &quot;position&quot;: &quot;absolute&quot;,
                        &quot;left&quot;: x + chart.margin.left - tooltipsOffset - selectionTooltipStart.outerWidth(),
                        &quot;top&quot;: y + chart.margin.top - tooltipsOffset - selectionTooltipStart.outerHeight(),
                        &quot;width&quot;: tooltipWidth
                    })
                    .text(startDateString)
                    .show();

                selectionTooltipStop
                    .css({
                        &quot;position&quot;: &quot;absolute&quot;,
                        &quot;left&quot;: x + width + chart.margin.left + tooltipsOffset,
                        &quot;top&quot;: y + height + chart.margin.top + tooltipsOffset,
                        &quot;width&quot;: tooltipWidth
                    })
                    .text(endDateString)
                    .show();

                selectionRect.attr({
                    &quot;x&quot;: x, //Update the selection rectangle in low profile mode
                    &quot;y&quot;: y,
                    &quot;width&quot;: width,
                    &quot;height&quot;: height
                }).style(&quot;fill-opacity&quot;, function(){
                    return (env.lowProfile == true) ? 0.5 : 0.2;
                });
            };


            // This function provides the selection feature in the normal mode
            updateSelectionNormal = function(){
                var selectionVertices, allCells;

                updateSelectionTimes--;

                if (currentElement != null &amp;&amp; updateSelectionTimes == 0){

                    allCells = env.mainView.d3Cells;

                    updateSelectionLowProfile();

                    dragStarted = true;

                    updateSelectionTimes = config.sensibilityFactorDuringSelection; // Reset the number of callback accepted

                    coordsMousemove = d3.mouse(currentElement); // Get the actual cursor position

                    endCoords = {x: coordsMousemove[0], y: coordsMousemove[1]};// Get the actual cursor position in our internal format

                    selectedRectsBoundingBox = {min: {x: Infinity, y: Infinity}, max: {x: -1, y: -1}}; //Reset the selection boundaries

                    finalStartCoords = {x: Math.min(startCoords.x, endCoords.x), y: Math.min(startCoords.y, endCoords.y)}; //Calculate the bounding box of the cells touched by the selection
                    finalEndCoords = {x: Math.max(startCoords.x, endCoords.x), y: Math.max(startCoords.y, endCoords.y)};

                    selectionVertices = utils.getRectangularVertexPoints(finalStartCoords.x, finalStartCoords.y, finalEndCoords.x - finalStartCoords.x, finalEndCoords.y - finalStartCoords.y); // Get Selection vertices


                    // This function finds the subset of cells outside the bounding box
                    allCells
                        .filter(function(d){
                            var out;
                            out = d.selected;

                            if (out == true){
                                d.selected = false;
                            }

                            return out;
                        })
                        .style(&quot;fill&quot;, getNormalCellColor); //Replace the color of the cells outside with the default one (useful for cells no longer involved in the selection)


                    // This function finds the subset of cells inside the bounding box
                    selectedCells = allCells
                        .filter(function(d){
                            var out, rectVertices, currentRect;

                            currentRect = d3.select(this); // Points the current cell

                            d.rectVertices = d.rectVertices || utils.getRectangularVertexPoints(d.xPosition, d.yPosition, parseFloat(currentRect.attr(&quot;width&quot;)), parseFloat(currentRect.attr(&quot;height&quot;))); // Calculate the cell vertices

                            rectVertices = d.rectVertices;

                            out = utils.isThereAnIntersection(selectionVertices, rectVertices);// &amp;&amp; d.selected == false; // Find if there is an intersection

                            if (out == true){
                                /*
                                 * Calculate the real bounding box based on cells boundaries
                                 */
                                selectedRectsBoundingBox.min = {x: Math.min(rectVertices[0].x, selectedRectsBoundingBox.min.x), y: Math.min(rectVertices[2].y, selectedRectsBoundingBox.min.y)};
                                selectedRectsBoundingBox.max = {x: Math.max(rectVertices[0].x, selectedRectsBoundingBox.max.x), y: Math.max(rectVertices[3].y, selectedRectsBoundingBox.max.y)};

                                d.selected = true;
                            }

                            return out;
                        })
                        .style(&quot;fill&quot;, getSelectedCellColor); //Change the color of the selected cells
                }
            };

            // This function is called when the user starts to select cells
            startSelection = function() {
                var mainView;

                mainView = env.mainView;

                mainView.popUp.hide(); // Cancel any popup
                mainView.showMessage(&#x27;&#x27;); // Cancel any message
                mainView.selectColumn(false); // Unselect column
                mainView.selectRow(false); // Unselect row

                env.timeEventsActive = false;

                dragStarted = false;

                document.onselectstart = function () {return false;}; //Cursor hack to avoid browser default dragging cursor

                currentElement = this;

                coords = d3.mouse(currentElement);

                startCoords = {x: coords[0], y: coords[1]};
                endCoords = {x: coords[0], y: coords[1]};


                if (env.lowProfile == true) {

                    d3.select(eventsAttachedOn.plain) //Attach the low profile callback for the mouse gestures
                        .on(&quot;mousemove&quot;, updateSelectionLowProfile);
                }


                if (selectionRect){ //Remove any possible old selection rectangles (can happen when the window goes out of focus)
                    selectionRect.remove();
                }

                selectionRect = svg //Introduce the selection rectangle
                    .append(&quot;rect&quot;)
                    .attr(&quot;class&quot;, &quot;selection-rect&quot;);

                selectionTooltipStart = $(&#x27;&lt;div class=&quot;dnsmon-tooltip selection-tooltip-start custom-jquery-ui-tooltip&quot;&gt;ciao&lt;/div&gt;&#x27;);
                selectionTooltipStop = $(&#x27;&lt;div class=&quot;dnsmon-tooltip selection-tooltip-stop custom-jquery-ui-tooltip&quot;&gt;ciao&lt;/div&gt;&#x27;);

                container.dom.$.append(selectionTooltipStart);
                container.dom.$.append(selectionTooltipStop);


                if (env.lowProfile == false){

                    d3.select(eventsAttachedOn.plain) //Attach the high profile callback for the mouse gestures
                        .on(&quot;mousemove&quot;, updateSelectionNormal);

                    getNormalCellColor = env.mainView.getCellColor;
                    getSelectedCellColor = env.mainView.getSelectedCellColor;
                    updateSelectionTimes = config.sensibilityFactorDuringSelection;
                }

                body.classed(&quot;stat-noselect&quot;, true);

                eventsAttachedOn.$
                    .on(&quot;mouseup.selection&quot;, stopSelection)
                    .on(&quot;keyup.selection&quot;, function(evt){
                        var key;

                        key = (evt.which) ? evt.which : evt.keyCode;
                        if (key == 27){ // Esc
                            removeSelectionWithFeedback(evt);
                        }
                    });

            };

            // This function is called when the user stops to select cells
            stopSelection = function(evt) {
                var zoomAnimationDuration, zoomAnimationDelay, selectionWithdrawalDuration;

                zoomAnimationDuration = config.zoomAnimationDuration;
                zoomAnimationDelay = config.zoomAnimationDelay;
                selectionWithdrawalDuration = config.selectionWithdrawalDuration;

                if (currentElement == null){
                    return;
                }


                body.classed(&quot;stat-noselect&quot;, false);
                eventsAttachedOn.$.off(&quot;mouseup.selection&quot;).off(&quot;keyup.selection&quot;);
                env.mainView.selectColumn(false); // Unselect column
                env.mainView.selectRow(false); // Unselect row
                document.onselectstart = function () {return true;}; //Remove the cursor hack

                if (dragStarted == false){
                    $this._clickEvent(evt);

                    currentElement = null; // Reset it (also if not used in the same function)
                    if (selectionRect){
                        selectionRect.remove();
                    }
                    return;
                }

                selectionTooltipStart.remove();
                selectionTooltipStop.remove();


//                if (env.lowProfile == true){ //Enlarge the selection rect to give the feeling of a zoom action

                selectedRectsBoundingBox.min = {x: Math.min(startCoords.x, endCoords.x), y: Math.min(startCoords.y, endCoords.y)};
                selectedRectsBoundingBox.max = {x: Math.max(startCoords.x, endCoords.x), y: Math.max(startCoords.y, endCoords.y)};

                removeRect = function(){ //This function will be pushed as a callback of the redraw function in order to remove the selection rect if the selection is not applicable
                    selectionRect
                        .transition()
                        .duration(zoomAnimationDuration)
                        .delay(zoomAnimationDelay)
                        .attr(&quot;x&quot;, 0)
                        .attr(&quot;y&quot;, 0)
                        .attr(&quot;width&quot;, chart.width())
                        .attr(&quot;height&quot;, chart.height())
                        .remove();

                    env.timeEventsActive = true;
                };
//                }

                if (!$this._computeSubDomainsAndApply(selectedRectsBoundingBox.min, selectedRectsBoundingBox.max, removeRect)){ //checks if the new subselection is not applicable

                    env.timeEventsActive = true;
//                    if (env.lowProfile == true){

                    selectionRect
                        .transition()
                        .duration(selectionWithdrawalDuration)
                        .attr(&quot;x&quot;, (selectedRectsBoundingBox.max.x - selectedRectsBoundingBox.min.x)/2 + selectedRectsBoundingBox.min.x)
                        .attr(&quot;y&quot;, (selectedRectsBoundingBox.max.y - selectedRectsBoundingBox.min.y)/2 + selectedRectsBoundingBox.min.y)
                        .attr(&quot;width&quot;, 0)
                        .attr(&quot;height&quot;, 0)
                        .remove();

//                    }else{

                    selectedCells //Gives a feedback to the user about the inapplicability of the subselection
                        .style(&quot;fill&quot;, config.style.noSelectableAreaColor)
                        .transition()
                        .duration(selectionWithdrawalDuration)
                        .style(&quot;fill&quot;, getNormalCellColor);
//                    }
                };

                currentElement = null; //Reset the selection start point
                trackerDomElement
                    .on(&quot;mousemove&quot;, null);
            };

            trackerDomElement
                .on(&quot;mousedown&quot;, startSelection);
        };


        /**
         * This function is called when an user clicks on a cell
         *
         * @method _clickEvent
         * @private
         */

        this._clickEvent = function(evt){
            var selectedCellData, target;

            env.timeEventsActive = true;
            target = d3.select(evt.target);
            selectedCellData = target[0][0][&quot;__data__&quot;];
            if (selectedCellData){
                env.mainView.controlPanel.showExtraInfoDialog(selectedCellData);
            }

        };


        /**
         * This function computes the new sub-domain after a selection
         *
         * @method _computeSubDomains
         * @private
         * @param {Number} finalStartCoords The top-left point of the selection
         * @param {Number} finalEndCoords The bottom-right point of the selection
         * @return {Array} The new domain
         */

        this._computeSubDomains = function(finalStartCoords, finalEndCoords){
            var newXDomain, newXRange, newYRange, newYDomain;

            newXRange = [finalStartCoords.x, finalEndCoords.x];

            newYRange = [finalStartCoords.y, finalEndCoords.y];
            newXDomain = env.mainView.xAxis.getSubDomain(newXRange);
            newYDomain = env.mainView.yAxis.getSubDomain(newYRange);

            return [newXDomain, newYDomain];
        };


        /**
         * This function computes and applies the new sub-domain after a selection
         *
         * @method _computeSubDomainsAndApply
         * @private
         * @param {Number} startCoords The top-left point of the selection
         * @param {Number} endCoords The bottom-right point of the selection
         * @param {Function} callback A callback function
         * @return {Boolean} True if the new domain is applied
         */

        this._computeSubDomainsAndApply = function(startCoords, endCoords, callback){
            var newXDomain, newYDomain, domains, row, tmpSelectedRows, tmpStartDate, tmpEndDate;

            domains = this._computeSubDomains(startCoords, endCoords);
            newXDomain = domains[0];
            newYDomain = domains[1];

            if ((newXDomain.length &gt; 0 ) &amp;&amp;
                (newYDomain.length &gt; 0)) {  // Zoom damper

                tmpStartDate = newXDomain[0];
                tmpEndDate = newXDomain[1];

                tmpSelectedRows = [];


                for (var n=0,length=env.mainView.rows.length; n&lt;length ;n++){
                    row = env.mainView.rows[n];

                    if (utils.indexOf(row.label, newYDomain) != -1){
                        tmpSelectedRows.push(row.id);
                        this.rowsSubSelection = true;
                    }
                }

                if (env.mainView.timeController.isSubSelectable(tmpStartDate, tmpEndDate, tmpSelectedRows)){ // Check if the sub-selection is possible

                    env.params.selectedRows = tmpSelectedRows;
                    env.params.filterProbes = true;
                    env.params.startDate = tmpStartDate;
                    env.params.endDate = tmpEndDate;

                    env.mainView.redraw(callback, this);
                    return true;

                }else if (env.mainView.timeController.isSelectionReduced(tmpSelectedRows)){ // Check if the selection is a sub-selection

                    env.params.selectedRows = tmpSelectedRows; //Don&#x27;t change time
                    env.params.filterProbes = true;
                    env.mainView.redraw(callback, this);
                    env.mainView.showMessage(env.lang.minimumTimeSelectionReached);
                    return true;

                }else{

                    env.mainView.showMessage(env.lang.tooZoomedMessage); //SubSelection failed
                    return false;
                }
            }
        }

    };

    return GesturesManager;
});



    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
