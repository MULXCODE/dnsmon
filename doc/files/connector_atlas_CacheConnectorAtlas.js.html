<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>connector/atlas/CacheConnectorAtlas.js - DNSMON</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="../assets/favicon.png">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="../assets/css/logo.png" title="DNSMON"></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 14.4.25.2</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="../classes/AggregationLevelConnector.html">AggregationLevelConnector</a></li>
            
                <li><a href="../classes/AntiFloodConnector.html">AntiFloodConnector</a></li>
            
                <li><a href="../classes/BreadcrumbsView.html">BreadcrumbsView</a></li>
            
                <li><a href="../classes/CacheConnectorAtlas.html">CacheConnectorAtlas</a></li>
            
                <li><a href="../classes/Cell.html">Cell</a></li>
            
                <li><a href="../classes/Connector.html">Connector</a></li>
            
                <li><a href="../classes/ConnectorFacade.html">ConnectorFacade</a></li>
            
                <li><a href="../classes/ControlPanelView.html">ControlPanelView</a></li>
            
                <li><a href="../classes/ErrorsHandlerConnectorAtlas.html">ErrorsHandlerConnectorAtlas</a></li>
            
                <li><a href="../classes/FullScreenView.html">FullScreenView</a></li>
            
                <li><a href="../classes/GesturesManager.html">GesturesManager</a></li>
            
                <li><a href="../classes/HistoryManager.html">HistoryManager</a></li>
            
                <li><a href="../classes/IsolationLevelConnectorAtlas.html">IsolationLevelConnectorAtlas</a></li>
            
                <li><a href="../classes/MainView.html">MainView</a></li>
            
                <li><a href="../classes/ParamsManager.html">ParamsManager</a></li>
            
                <li><a href="../classes/PopUpView.html">PopUpView</a></li>
            
                <li><a href="../classes/Row.html">Row</a></li>
            
                <li><a href="../classes/SessionManager.html">SessionManager</a></li>
            
                <li><a href="../classes/SvgChartView.html">SvgChartView</a></li>
            
                <li><a href="../classes/SvgContainerView.html">SvgContainerView</a></li>
            
                <li><a href="../classes/SvgOrdinalAxisView.html">SvgOrdinalAxisView</a></li>
            
                <li><a href="../classes/SvgTimeAxisView.html">SvgTimeAxisView</a></li>
            
                <li><a href="../classes/TemplateManagerView.html">TemplateManagerView</a></li>
            
                <li><a href="../classes/TimeController.html">TimeController</a></li>
            
                <li><a href="../classes/TimeOverviewView.html">TimeOverviewView</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
                <li><a href="../modules/connector.html">connector</a></li>
            
                <li><a href="../modules/connector.Atlas.html">connector.Atlas</a></li>
            
                <li><a href="../modules/controller.html">controller</a></li>
            
                <li><a href="../modules/environment.html">environment</a></li>
            
                <li><a href="../modules/model.html">model</a></li>
            
                <li><a href="../modules/session.html">session</a></li>
            
                <li><a href="../modules/view.html">view</a></li>
            
                <li><a href="../modules/view.svg.html">view.svg</a></li>
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: connector/atlas/CacheConnectorAtlas.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
/**
 * Created with JetBrains WebStorm.
 * User: mcandela
 * Date: 10/16/13
 * Time: 4:38 PM
 * To change this template use File | Settings | File Templates.
 */

define(
    [
        &quot;env.utils&quot;,
        &quot;connector.atlas.error-handler&quot;
    ],
    function(utils, Connector){

        /**
         * CacheConnectorAtlas is the cache level dedicated to the atlas data-api for DNSMON.
         * It provides a bottom-up incremental cache and top-down decremental queries.
         *
         * @class CacheConnectorAtlas
         * @constructor
         * @module connector.Atlas
         */

        var CacheConnectorAtlas = function(env){
            var connector, dataNomenclatureMapping, minimumResultDate, maximumResultDate;

            connector = new Connector(env);

            env.totalSavedBytes = 0;

            // The map declaring the low-level data nomenclature
            dataNomenclatureMapping = {
                startTime: &quot;start_time&quot;,
                endTime: &quot;end_time&quot;,
                aggregationLevel: &quot;aggregation&quot;,
                probesList: &quot;probes&quot;,
                serversList: &quot;servers&quot;,
                aggregationLevels: &quot;aggregation_levels&quot;,
                measurementStartTime: &quot;earliest_available&quot;,
                measurementEndTime: &quot;latest_available&quot;,
                aggregationLabel: &quot;aggregation_label&quot;,
                nativeAvailable: &quot;native_available&quot;,

                server: {
                    id: &quot;id&quot;,
                    label: &quot;label&quot;,
                    group: &quot;grouping&quot;,
                    resultsList: &quot;results&quot;,
                    ipVersion: &quot;ip_version&quot;,
                    description: &quot;description&quot;
                },

                probe: {
                    id: &quot;id&quot;,
                    label: &quot;label&quot;,
                    group: &quot;grouping&quot;,
                    resultsList: &quot;results&quot;,
                    description: &quot;description&quot;
                },

                result: {
                    respondingTime: &quot;rtt50&quot;,
                    packetSent: &quot;queries&quot;,
                    packetReceived: &quot;replies&quot;,
                    time: &quot;time&quot;
                }
            };


            // Initialise the cache
            this.cache = {
                data: null,
                params: null,
                aggregationLevel: null
            };


            /**
             * It is strongly related to a particular JSON format.
             * From top to bottom: tries to reduce the amount of data requested based on the available data in cache.
             * From bottom to top: enrich the retrieved subset of data with the data already in cache.
             *
             * @method retrieveData
             * @param {Object} params A parameters vector
             * @param {Function} callback A function taking the retrieved data as input when it is ready
             * @param {Object} context The context of the callback
             */

            this.retrieveData = function(params, callback, context){

                if (env.localCacheActive &amp;&amp; this.cache.data){ // Is the cache active and available

                    if (this._isCacheFilteredServerSide(params)) { // The server side is computing the diff (e.g. because the client doesn&#x27;t know the time window that will be returned)

                        //this._composeQueryOnUpdate(params, callback, context); // To be tested

                    }else if (this._isCacheEnough(params)){ // The whole query is in cache

                        utils.log(&quot;Query in cache&quot;, env.debugMode);
                        this._composeQueryOnCache(params, callback, context);

                    }else if (this._isCachePartiallyValid(params)){ // A portion of the query is in the cache

                        utils.log(&quot;Query partially in cache&quot;, env.debugMode);
                        this._retrieveQuerySubset(params, callback, context);

                    }else{

                        this._retrieveWithoutCache(params, callback, context); // The cache is active and available but not related to the actual query

                    }

                }else{

                    this._retrieveWithoutCache(params, callback, context); // The cache is not active or empty

                }

            };


            /**
             * This method retrieves from the data-api a portion of the query.
             * It describes the available data in cache and the data-api provides the remaining parts
             *
             * @method _composeQueryOnUpdate
             * @private
             * @param {Object} params A parameters vector
             * @param {Function} callback A function taking the retrieved data as input when it is ready
             * @param {Object} context The context of the callback
             */

            this._composeQueryOnUpdate = function(params, callback, context){
                var totalBytes, savedBytes;

                connector.retrieveData(params, function(data){

                    // Set the time boundaries retrieved from the server
                    params.startTime = data[dataNomenclatureMapping.startTime];
                    params.endTime = data[dataNomenclatureMapping.endTime];

                    data = this._mergeData(params, this.cache.data, data);
                    data = this._filterData(params, data);

                    if (env.debugMode){
                        totalBytes = utils.objectSize(data);
                        savedBytes = totalBytes - env.lastDownloadBytes;
                        env.totalSavedBytes += savedBytes;
                        utils.log(&#x27;Retrieved bytes: &#x27; + env.lastDownloadBytes + &#x27; Total bytes: &#x27; + totalBytes + &#x27; Saved bytes: &#x27; +  savedBytes, env.debugMode);
                        utils.log(&#x27;Total bytes saved until now: &#x27; + env.totalSavedBytes, env.debugMode);
                    }

                    this._updateCache(params, data);

                    callback.call(context, data);

                }, this);
            };


            /**
             * This method checks if the data-api should filter the data or not.
             *
             * @method _isCacheFilteredServerSide
             * @private
             * @param {Object} params A parameters vector
             * @return {Boolean} True if the data-api should filter the data
             */

            this._isCacheFilteredServerSide = function(params){
                return (
                    params.startTime == null &amp;&amp;
                    params.endTime == null &amp;&amp;
                    params.timeWindow != null &amp;&amp;
                    params.cutFrom != null
                    );
            };


            /**
             * This method answers to the request by filtering the data in cache.
             * It usable only when the whole query is in cache.
             *
             * @method _composeQueryOnCache
             * @private
             * @param {Object} params A parameters vector
             * @param {Function} callback A function taking the composed data as input when it is ready
             * @param {Object} context The context of the callback
             */

            this._composeQueryOnCache = function(params, callback, context){
                var filteredCacheData, totalBytes, savedBytes;

                filteredCacheData = this._filterData(params, this.cache.data);
                this._updateCache(params, filteredCacheData);

                if (env.debugMode){
                    totalBytes = utils.objectSize(filteredCacheData);
                    savedBytes = totalBytes;
                    env.totalSavedBytes += savedBytes;
                    utils.log(&#x27;Retrieved bytes: 0 Total bytes: &#x27; + totalBytes + &#x27; Saved bytes: &#x27; +  savedBytes, env.debugMode);
                    utils.log(&#x27;Total bytes saved until now: &#x27; + env.totalSavedBytes, env.debugMode);
                }

                callback.call(context, this.cache.data);
            };


            /**
             * This method answers to the request by composing the answer from the cache and the server.
             * It computes the data not available in cache and asks to the server for it.
             *
             * @method _retrieveQuerySubset
             * @private
             * @param {Object} params A parameters vector
             * @param {Function} callback A function taking the composed data as input when it is ready
             * @param {Object} context The context of the callback
             */

            this._retrieveQuerySubset = function(params, callback, context){
                var subsetParams, totalBytes, savedBytes, newAggregationLevels, oldAggregationLevels;

                subsetParams = this._getParamsSubset(this.cache.params, params);

                subsetParams.aggregationLevel = env.aggregationLevel; // Force the aggregation level

                connector.retrieveData(subsetParams, function(data){

                    oldAggregationLevels = this.cache.data[dataNomenclatureMapping.aggregationLevels];
                    newAggregationLevels = data[dataNomenclatureMapping.aggregationLevels];

                    if (newAggregationLevels.length != oldAggregationLevels.length || !utils.containsAll(newAggregationLevels, oldAggregationLevels)) { // If the aggregations list changes

                        this._retrieveWithoutCache(params, callback, context);

                    }else{

                        data = this._mergeData(params, this.cache.data, data);
                        data = this._filterData(params, data);

                        if (env.debugMode) {
                            totalBytes = utils.objectSize(data);
                            savedBytes = totalBytes - env.lastDownloadBytes;
                            env.totalSavedBytes += savedBytes;
                            utils.log(&#x27;Retrieved bytes: &#x27; + env.lastDownloadBytes + &#x27; Total bytes: &#x27; + totalBytes + &#x27; Saved bytes: &#x27; + savedBytes, env.debugMode);
                            utils.log(&#x27;Total bytes saved until now: &#x27; + env.totalSavedBytes, env.debugMode);
                        }

                        this._updateCache(params, data);

                        callback.call(context, data);
                    }

                }, this);

            };


            /**
             * This method computes the difference between two parameters vector
             *
             * @method _getParamsSubset
             * @private
             * @param {Object} oldParams The old parameters vector
             * @param {Object} newParams The new parameters vector
             * @return {Object} The resulting parameters vector
             */

            this._getParamsSubset = function(oldParams, newParams){
                var params, timeDiff;

                params = utils.lightClone(newParams); // Clone the parameters vector

                //params.selectedRows = this._getRowsDiff(oldParams.selectedRows, newParams.selectedRows); // Get the new rows not included in the previous query

                timeDiff = this._getTimeDiff(this.cache.data[dataNomenclatureMapping.startTime], this.cache.data[dataNomenclatureMapping.endTime], newParams.startTime, newParams.endTime); // Get the diff in time boundaries

                params.startTime = timeDiff.startTime; // Set the new time boundaries
                params.endTime = timeDiff.endTime;

                return params;
            };


            /**
             * This method computes the difference between two time windows
             *
             * @method _getTimeDiff
             * @private
             * @param {Date} oldStartTime The old start date
             * @param {Date} oldEndTime The old end date
             * @param {Date} newStartTime The new start date
             * @param {Date} newEndTime The new end date
             * @return {Object} The computed time window (composed of startTime and endTime)
             */

            this._getTimeDiff = function(oldStartTime, oldEndTime, newStartTime, newEndTime){
                var startTime, endTime, consistencyOffset;

                consistencyOffset = env.aggregationLevel / 2;

                if (newStartTime &lt; oldStartTime){

                    startTime = newStartTime;
                    endTime = oldStartTime;

                }else if (newEndTime &gt; oldEndTime){

                    startTime = oldEndTime - consistencyOffset;
                    endTime = newEndTime;

                }

                return {startTime: startTime, endTime: endTime};
            };


            /**
             * This method checks if the actual cache is partially valid or not.
             *
             * @method _isCachePartiallyValid
             * @private
             * @param {Object} params A parameters vector
             * @return {Boolean} True if the actual cache is partially valid
             */

            this._isCachePartiallyValid = function(params){
                var oldParams, oldRows, newRows;

                oldParams = this.cache.params;

                oldRows = utils.split(oldParams.selectedRows, &#x27;,&#x27;, true);
                newRows = utils.split(params.selectedRows, &#x27;,&#x27;, true);

                return (
                    params.startTime != null &amp;&amp;
                    params.endTime != null &amp;&amp;
                    this._isSameTarget(params) &amp;&amp; // Same target
                    this.cache.aggregationLevel == env.aggregationLevel &amp;&amp; // Check the aggregation level

                    // Same rows
                    oldRows.length == newRows.length &amp;&amp;
                    this._containsRows(oldRows, newRows) &amp;&amp;

                    (
                        (params.startTime &gt;= oldParams.startTime  &amp;&amp; params.startTime &lt;= oldParams.endTime) || // Different time but partially valid
                        (params.endTime &gt;= oldParams.startTime  &amp;&amp; params.endTime &lt;= oldParams.endTime)
                        )
                    );
            };


            /**
             * This method updates the cache
             *
             * @method _updateCache
             * @private
             * @param {Object} params The new parameters vector
             * @param {Object} data The blob of data
             */

            this._updateCache = function(params, data){

                this.cache = {
                    data: data,
                    params: utils.lightClone(params),
                    aggregationLevel: env.aggregationLevel
                };

            };


            /**
             * This method checks if a new row selection contains the old rows selected.
             *
             * @method _containsRows
             * @private
             * @param {Object} params The old vector of selected rows
             * @param {Object} params The new vector of selected rows
             * @return {Boolean} True if the new row selection contains the old rows selected
             */

            this._containsRows = function(oldRowsSelection, newRowsSelection){

                return oldRowsSelection.length == 0 || (newRowsSelection.length != 0 &amp;&amp; utils.containsAll(oldRowsSelection, newRowsSelection));

            };


            /**
             * This method rely on the layers below to answer the query
             *
             * @method _retrieveWithoutCache
             * @private
             * @param {Object} params A parameters vector
             * @param {Function} callback A function taking the data as input when it is ready
             * @param {Object} context The context of the callback
             */

            this._retrieveWithoutCache = function(params, callback, context){

                connector.retrieveData(params, function(data){

                    this._updateCache(params, data);

                    utils.log(&#x27;Retrieved bytes: &#x27; + env.lastDownloadBytes, env.debugMode);
                    callback.call(context, data);
                }, this);

            };


            /**
             * This method checks if the actual cache is completely valid or not.
             *
             * @method _isCacheEnough
             * @private
             * @param {Object} params A parameters vector
             * @return {Boolean} True if the actual cache is completely valid
             */

            this._isCacheEnough = function(params){
                var oldParams;

                oldParams = this.cache.params;

                return (
                    params.startTime != null &amp;&amp;
                    params.endTime != null &amp;&amp;
                    this._isSameTarget(params) &amp;&amp;
                    this.cache.aggregationLevel == env.aggregationLevel &amp;&amp;
                    this._containsRows(utils.split(oldParams.selectedRows, &#x27;,&#x27;, true), utils.split(params.selectedRows, &#x27;,&#x27;, true)) &amp;&amp;
                    oldParams.startTime &lt;= params.startTime &amp;&amp;
                    oldParams.endTime &gt;= params.endTime
                    );
            };


            /**
             * This method filters the data in order to satisfy the actual parameters
             *
             * @method _filterData
             * @private
             * @param {Object} params The new parameters vector
             * @param {Object} data The blob of data
             * @return {Object} The filtered data
             */

            this._filterData = function(params, data){
                minimumResultDate = null;
                maximumResultDate = null;

                this._filterRows(params, data);

                // Updates the composed JSON with the actual start/end dates
                data[dataNomenclatureMapping.startTime] = ( minimumResultDate + (env.aggregationLevel || env.samplingFrequency)  &gt;= params.startTime) ? params.startTime : minimumResultDate;
                data[dataNomenclatureMapping.endTime] = ( maximumResultDate + (env.aggregationLevel || env.samplingFrequency)  &gt;= params.endTime) ? params.endTime : maximumResultDate;

                return data;
            };


            /**
             * This method filters the rows on a blob of data in order to satisfy a vector of parameters
             *
             * @method _filterRows
             * @private
             * @param {Object} params A parameters vector
             * @param {Object} data The blob of data
             */

            this._filterRows = function(params, data){
                var rows, newResults, row, rowId, selectedRows, rowsListNomenclature;

                newResults = [];
                selectedRows = utils.split(params.selectedRows, &#x27;,&#x27;, true);
                rowsListNomenclature = this._getRowsListNomenclature(params);
                rows = data[rowsListNomenclature];

                for (var n=0,length=rows.length; n&lt;length; n++){
                    row = rows[n];

                    rowId = &#x27;&#x27; + row[this._getRowNomenclature(params).id]; // Is a string

                    if (selectedRows.length == 0 || utils.indexOf(rowId, selectedRows) != -1){
                        newResults.push(row);

                        this._filterResults(params, row);
                    }
                }

                data[rowsListNomenclature] = newResults; //Replace the filtered data
            };


            /**
             * This method filters the results in a row in order to satisfy a vector of parameters
             *
             * @method _filterRows
             * @private
             * @param {Object} params A parameters vector
             * @param {Object} row A row (a group of results)
             */

            this._filterResults = function(params, row){
                var result, newResults, results, rowNomenclature;

                newResults = [];
                rowNomenclature = this._getRowNomenclature(params);
                results = row[rowNomenclature.resultsList];

                for (var n=0,length=results.length; n&lt;length; n++){
                    result = results[n];

                    // Get the new time boundaries
                    if (result.time &lt; params.endTime &amp;&amp; result.time &gt;= params.startTime){
                        minimumResultDate = (result.time &lt; minimumResultDate || !minimumResultDate) ? result.time : minimumResultDate;
                        maximumResultDate = ((result.time + env.aggregationLevel &gt; maximumResultDate) || !maximumResultDate) ? result.time + env.aggregationLevel : maximumResultDate;
                        newResults.push(result);
                    }

                }

                row[rowNomenclature.resultsList] = newResults; //Replace the filtered data
            };


            /**
             * This method checks if the provided parameters are referring to the same target/measurement/contest.
             *
             * @method _isSameTarget
             * @private
             * @param {Object} newParams The new parameters vector
             * @return {Boolean} True if is the same target/measurement/contest
             */

            this._isSameTarget = function(newParams){
                var oldParams, importantParams, paramTmp;

                oldParams = this.cache.params;
                importantParams = [&quot;root&quot;, &quot;group&quot;, &quot;type&quot;, &quot;ipVersion&quot;, &quot;isTcp&quot;];


                for (var n=0,length=importantParams.length; n&lt;length; n++){
                    paramTmp = importantParams[n];

                    if (oldParams[paramTmp] != newParams[paramTmp]){
                        return false;
                    }
                }

                return true;
            };


            /**
             * This method merges two blob of data
             *
             * @method _mergeData
             * @private
             * @param {Object} params The new parameters vector
             * @param {Object} oldData The old blob of data
             * @param {Object} newData The new blob of data
             * @return {Object} The merged blob of data
             */

            this._mergeData = function(params, oldData, newData){

                return this._mergeRows(params, oldData, newData);

            };


            /**
             * This support method merges the rows of two blob of data
             *
             * @method _mergeData
             * @private
             * @param {Object} params The new parameters vector
             * @param {Object} oldData The old blob of data
             * @param {Object} newData The new blob of data
             * @return {Object} The merged blob of data
             */

            this._mergeRows = function(params, oldData, newData){
                var dataRows, oldDataRows, row, rowId, oldRow, results, newResults, resultsListNomenclature, rowsListNomenclature;

                rowsListNomenclature = this._getRowsListNomenclature(params);
                dataRows = newData[rowsListNomenclature];
                oldDataRows = oldData[rowsListNomenclature];


                for (var n=0,length=dataRows.length; n&lt;length; n++){
                    row = dataRows[n];

                    rowId = &#x27;&#x27; + row[this._getRowNomenclature(params).id];
                    oldRow = this._getRow(params, oldData, rowId);

                    if (!oldRow){

                        oldDataRows.push(row);

                    }else{
                        resultsListNomenclature = this._getRowNomenclature(params).resultsList;
                        results = oldRow[resultsListNomenclature];
                        newResults = row[resultsListNomenclature];
                        oldRow[resultsListNomenclature]  = results.concat(newResults);

                    }

                }

                oldData[dataNomenclatureMapping.startTime] = Math.min(oldData[dataNomenclatureMapping.startTime], newData[dataNomenclatureMapping.startTime]);
                oldData[dataNomenclatureMapping.endTime] = Math.max(oldData[dataNomenclatureMapping.endTime], newData[dataNomenclatureMapping.endTime]);

                return oldData;
            };


            /**
             * This method returns the nomenclature of a group for the given query type
             *
             * @method _getRowNomenclature
             * @private
             * @param {Object} params A parameters vector
             * @return {String} The nomenclature
             */

            this._getRowNomenclature = function(params){

                switch (params.type){
                    case &quot;zone-servers&quot;:
                        return dataNomenclatureMapping.server;
                        break;

                    case &quot;server-probes&quot;:
                        return dataNomenclatureMapping.probe;
                        break;
                }
            };


            /**
             * This method returns the nomenclature of a list of groups for the given query type
             *
             * @method _getRowsListNomenclature
             * @private
             * @param {Object} params A parameters vector
             * @return {String} The nomenclature
             */

            this._getRowsListNomenclature = function(params){

                switch (params.type){
                    case &quot;zone-servers&quot;:
                        return dataNomenclatureMapping.serversList;
                        break;

                    case &quot;server-probes&quot;:
                        return dataNomenclatureMapping.probesList;
                        break;
                }
            };


            /**
             * This method retrieves a row from a blob of data
             *
             * @method _getRow
             * @private
             * @param {Object} params A parameters vector
             * @param {Object} data A blob of data
             * @param {String} id The if of a row
             * @return {Object} A row or null
             */

            this._getRow = function(params, data, id){
                var rows, row, rowId;

                rows = data[this._getRowsListNomenclature(params)];
                for (var n=0,length=rows.length; n&lt;length; n++){
                    row = rows[n];
                    rowId = &#x27;&#x27; + row[this._getRowNomenclature(params).id];

                    if (rowId == id){
                        return row;
                    }
                }

                return null;
            };


            /**
             * Get the human readable version of the DNS response and use cache
             *
             * @method getNativeDnsResult
             * @param {Number} msmId The id of the measurement
             * @param {Number} prbId The id of the probe
             * @param {Number} timestamp A UNIX timestamp
             * @param {Function} callback A function taking the retrieved data as input when it is ready
             * @param {Object} context The context of the callback
             */

            this.getNativeDnsResult = function(msmId, prbId, timestamp, callback, context){ // Just indirection for now
                connector.getNativeDnsResult(msmId, prbId, timestamp, callback, context);
            };


            /**
             * Get the closest traceroutes and use cache
             *
             * @method getClosestTraceroutes
             * @param {Number} msmId The id of the measurement
             * @param {Number} prbId The id of the probe
             * @param {Number} timestamp A UNIX timestamp
             * @param {Function} callback A function taking the retrieved data as input when it is ready
             * @param {Object} context The context of the callback
             */

            this.getClosestTraceroutes = function(msmId, prbId, timestamp, callback, context){ // Just indirection for now
                connector.getClosestTraceroutes(msmId, prbId, timestamp, callback, context);
            };

        };

        return CacheConnectorAtlas;
    });
    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
